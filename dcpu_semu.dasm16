; DCPU sandboxing emultator for DCPU
;
;	dpu-semu is an emulator for DCPU written in DCPU assembly language.
;
;
; Copyright 2012 Brian Monkaba
;
; This file is part of dcpu_semu.
;
;    dcpu_semu is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    dcpu_semu is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with dcpu_semu.  If not, see <http://www.gnu.org/licenses/>.

; EMU register useage
; A = a (instruction not register)
; B = b (instruction not register)
; C = instuction (opcode)
; X = virtual register array pointer
; Y = temp storage / value a / decoded value a
; Z = temp storage
; I = virtual PC
; J = temp storage / value b / decoded value b
; SP = not used


; virtual process register structure (len 0x1f words)
; (X register points to the active process)
; use the registers to pass up to 7 arguments to the program
; X + 0x0 = A		arg A:	program argument A	
; X + 0x1 = B		arg B:	program argument B
; X + 0x2 = C		.
; X + 0x3 = X		.
; X + 0x4 = Y		.
; X + 0x5 = Z
; X + 0x6 = I
; X + 0x7 = J		arg J: set to the same value as MMU (base address & screen buffer info)
; X + 0x8 = OVERFLOW
; X + 0x9 = PC
; X + 0xA = SP
; X + 0xB = TICK
; X + 0xC = TIMER (will be used for priority task switching) (TODO)
; X + 0xD = virtual memory address offset (virtual 0x00 -- TODO)
; X + 0xE = virtual memory size (TODO)
; X + 0xF = memory managment unit (MMU): requires an assembler with an ORG preprocessor directive to relocate code
;	values:
;	 0x0000 = MMU disable 
;	 0xXXaa = MMU access, 7 pages of 8k words (8th page is shared memory):
;		0xXXX1 - r/w access from 0x0000 to 0x1FFF
;		0xXXX3 - r/w access from 0x2000 to 0x3FFF
;		0xXXX5 - r/w access from 0x4000 to 0x5FFF
;		0xXXX7 - r/w access from 0x6000 to 0x7FFF
;		0xXXX9 - r/w access from 0x8000 to 0x9FFF
;		0xXXXB - r/w access from 0xA000 to 0xBFFF
;		0xXXXD - r/w access from 0xC000 to 0xDFFF
;
; X + 0x10 = stack protection SP upper bound (TODO)
; X + 0x11 = stack protection SP lower bound (TODO)
; X + 0x12 = write back pointer (used for [next word + register] writes)
; X + 0x1E = service call timer		current service call timer (set to delay on call, decrements to zero
;					if greater than zero, service call will fail (return 0) - TODO
; X + 0x1F = service call delay		emulation cycles required between service calls - TODO

;
; The emulator can provide high level services (calls functions which run outside the emulation layer)
;
; OS DMA Service Call (VRA assignments)		
; A				arg A:	service call function (valid values: 0x01 - 0x0F) / return value: 0
; B				arg B:	service call argument B / return value: 0 = fail, 1 = ok
; C				.
; X				.
; Y				.
; Z				.
; I				.
; J				.

; to initiate a service call a program must set 0xXFFF to 0xBEEF
;     - where X is the highest page of access (mmu value of 9 would set 0x9FFF) or in case of a disabled mmu set 0xFFFF
; service calls always return a result in registers a & b, other registers may be used depending on the call
; the emulator checks the address and processes any pending service commands between every emulation cycle
; however, in order to prevent service call attacks, the frequecy in which the commands will be accepted will vary
; any additional calls beyond the allowed frequency will automaticaly fail (limits computation expense)



; memory layout
; 0xF000 - 0xF700 	emu core
; 0x3000 - 0x30A0 	VRA memory

;lookup tables (function pointers)
; 0x6300 - OS service calls
; 0x6200 - extended instructions
; 0x6000 - basic instructions
; 0x5500 - value b loaders
; 0x5100 - write back functions
; 0x5000 - value a loaders

; quick summary:
;
;	before emulation begins the look up tables are built
;	for read / execute / write cpu operations
;
;	walk through of an emulation cycle:
;	1) load the instruction pointed to by the virtual PC
;	2) deconstruct the op code into the three components:
;		a) opcode is stored in C
;		b) value type (see cpu spec) is stored in A for 'a' 
;		c) value type (see cpu spec) is stored in B for 'b
;	3) values are decoded (loaded), value of 'a' is stored in Y, 'b' in J
;	4) opcode is executed (ex: SET Y, J)
;	5) result is stored (write back)
;	6) post execute increments PC if needed and implements EMU features (ex: TICK)
;
;	load->decode->execute->writeback->postexe

;first instruction jumps to the emulator initialization
SET PC, start_semu



;
;	TEST PROGRAMS
;
; 	- These are the programs being emulated
;
;
;

	ORG 0x1000
;
; mmu corruption test program.
; the program will loop through the entire address range attempting to corrupt memory.
;


:corrupt_mem
	SET X, 0x2000  ;start towards the end of the writeable memory range 
:cm_l	ADD X, 0x01
	SET [X], 0xDEAD	;writes should only be enabled between 0x1000 - 0x2FFF
	SET PC, cm_l


	ORG 0x8800
;
; program to draw spinner to screen
;

:spin
	SET Z, 0x8000
	SET I, spin_text	
:s_next	SET C, [I]	;get the text char
	ADD I, 0x01
        BOR C, 0xA000
	SET [Z], C		;write the char
	IFE [I], 0xFFFF		;check for end of text
	SET I, spin_text
	SET A, 0x04		;delay
:s_dly	SUB A, 0x01
	IFE A, 0x00
	SET PC, s_next
	SET PC, s_dly


;
; program to draw status bar
;

:bar
	SET Z, 0x8160
	SET I, bar_text

:b_grow	SET C, [I]	;get the text char
	ADD I, 0x01
        BOR C, 0xEA00
	SET [Z], C		;write the char
	IFE [I], 0xFFFF		;check for end of text
	SET I, bar_text
	ADD Z, 0x01
	IFE Z, 0x817f
	SET PC, b_shrnk
	SET PC, b_grow	

:b_shrnk
	AND [Z], 0xE3FF
	SUB Z, 0x01
	IFE Z, 0x8160
	SET PC, b_grow
	SET PC, b_shrnk

;
; program to write keyboard input to screen
;

:test_pgmc

:loopd	
	SET A, 0x01		;clear screen service call
	SET B, 0x0000		;set the background color
	SET [0x9FFF],0xBEEF 	;try the service call

; replaced old emulated screen clear routine with the clear screen service call.
;	SET Z, 0x801F	;clear the screen	
;	SET X, 0x4400	;set the color
;:contc	ADD Z, 0x01
;	SET [Z], X
;	IFG 0x815F, Z
;	SET PC, contc

	SET Z, 0x8020	;reset screen pointer

:waitc	SET C, [0x9000]	;get the input
	IFE C, 0x0000	;wait for next char
	SET PC, waitc

	;IFE C, 0x0020
	;BOR C, 0xAA00

        BOR C, 0xAE00
	SET [Z], C		;write the char (w/ cursor)
        AND [0xFFFE+Z], 0xF0FF	;remove previous cursor
	SET [0x9000], 0x0000	;clear the keyboard input
	ADD Z, 0x001		;increment the screen pointer
	IFG Z, 0x815F		;check for end of screen buffer
	SET PC, loopd
	SET PC, waitc

;
; program to simulate keyboard input
;

:test_pgmd
	SET I, string	;index
	SET X, 0x9000	;destination 
:contd	SET C, [I]	;char
	ADD I, 0x01	;inc index

	IFE C, 0xFFFF 	;check for end of string
	SET I, string	;reset index
	IFE C, 0xFFFF 	;check for end of string
	SET PC, test_pgmd ;restart

	SET [X], C	;insert input into keyboard buffer and
:waitd	IFE [X], 0x00	;wait until it's taken
	SET PC, contd	;input taken, continue

	SET PC, waitd	;else wait



;
; data
;

:string DAT "O------------------------------O"
	DAT "|  SSSS  EEEEE M    M U   U    |"
	DAT "| S      E     MM  MM U   U    |"
	DAT "|  SSSS  EEEE  M MM M U   U    |"
	DAT "|      S E     M    M U   U    |"
	DAT "|  SSSS  EEEEE M    M  UUU     |"
	DAT "|                              |"
	DAT "| Sandboxing Emulator for DCPU |"
	DAT "|                         v0.2 |"
	DAT "O------------------------------O"

	DAT "O------------------------------O"
	DAT "| Features:                    |"
	DAT "|                              |"
	DAT "|  1) Pre-emptive Multitasking |"
	DAT "|  2) Memory Management Unit   |"
	DAT "| 	3) Virtual Register Arrays  |"
	DAT "|  4) Isolated Circular Stacks |"
	DAT "|  5) OS service calls         |"
	DAT "|                              |"
	DAT "O------------------------------O"
	
	DAT "O------------------------------O"
	DAT "| Five programs are now        |"
	DAT "| running in parallel.         |"
	DAT "|                              |"
	DAT "| 1) keyboard screen writer    |"
	DAT "| 2) keyboard input simulator  |"
	DAT "| 3) MMU (corruption) test     |"
	DAT "| 4) spinner                   |"
	DAT "| 5) status bar                |"
	DAT "O------------------------------O"

	;end of string delimiter
	DAT 0xFFFF

:spin_text	DAT "|/_\|/_\\",0xFFFF 

:bar_text	DAT "Shields||||||||||||||||||||||||",0xFFFF 

;
;	Start of SEMU code
;
;

ORG 0xF000
:start_semu

;
; print splash screen
;

;:splash
;	SET I, string	;index
;	SET X, 0x8000	;destination 
;:s_cont	SET C, [I]
;	IFE C, 0xFFFF
;	SET PC, init
;	BOR C, 0xA200
;	SET [X], C
;	ADD X, 0x01
;	ADD I, 0x01
;	SET PC, s_cont 

;
; initialize the virtual register arrays (VRA)
;

:init
	;set up the virtual register arrays and point to the test programs
	SET X, 0x3000
	SET [0x00+X], 0x00	;A
	SET [0x01+X], 0x00	;B
	SET [0x02+X], 0x00	;C
	SET [0x03+X], 0xFFFF	;X
	SET [0x04+X], 0x00	;Y
	SET [0x05+X], 0x7FFF	;Z
	SET [0x06+X], 0x00	;I
	SET [0x07+X], 0x00	;J
	SET [0x08+X], 0x00	;OVERFLOW
	SET [0x09+X], test_pgmc	;PC
	SET [0x0A+X], 0x99FF	;SP
	SET [0x0B+X], 0x00	;TICK
	SET [0x0C+X], 0x00	;TIMER
	SET [0x0F+X], 0x09	;MMU (write enable range 0x8000-0x9FFF)
	SET [0x12+X], 0x00	;write back pointer

	SET X, 0x3020
	SET [0x00+X], 0x5A	;A
	SET [0x01+X], 0x5A	;B
	SET [0x02+X], 0x5A	;C
	SET [0x03+X], 0x5A5A	;X
	SET [0x04+X], 0x5A	;Y
	SET [0x05+X], 0x8150	;Z
	SET [0x06+X], 0x5A	;I
	SET [0x07+X], 0x5A	;J
	SET [0x08+X], 0x5A	;OVERFLOW
	SET [0x09+X], test_pgmd	;PC
	SET [0x0A+X], 0x9CFF	;SP
	SET [0x0B+X], 0x00	;TICK
	SET [0x0C+X], 0x00	;TIMER
	SET [0x0F+X], 0x09	;MMU (write enable range 0x8000-0x9FFF)
	SET [0x12+X], 0x00	;write back pointer

	SET X, 0x3040
	SET [0x00+X], 0x00	;A
	SET [0x01+X], 0x00	;B
	SET [0x02+X], 0x00	;C
	SET [0x03+X], 0x00	;X
	SET [0x04+X], 0x00	;Y
	SET [0x05+X], 0x00	;Z
	SET [0x06+X], 0x00	;I
	SET [0x07+X], 0x00	;J
	SET [0x08+X], 0x00	;OVERFLOW
	SET [0x09+X], corrupt_mem	;PC
	SET [0x0A+X], 0x2FFF	;SP
	SET [0x0B+X], 0x00	;TICK
	SET [0x0C+X], 0x00	;TIMER
	SET [0x0F+X], 0x02	;MMU (write enable range 0x1000-0x2FFF)
	SET [0x12+X], 0x00	;write back pointer

	SET X, 0x3060
	SET [0x00+X], 0x00	;A
	SET [0x01+X], 0x00	;B
	SET [0x02+X], 0x00	;C
	SET [0x03+X], 0x00	;X
	SET [0x04+X], 0x00	;Y
	SET [0x05+X], 0x00	;Z
	SET [0x06+X], 0x00	;I
	SET [0x07+X], 0x00	;J
	SET [0x08+X], 0x00	;OVERFLOW
	SET [0x09+X], spin	;PC
	SET [0x0A+X], 0x00	;SP
	SET [0x0B+X], 0x00	;TICK
	SET [0x0C+X], 0x00	;TIMER
	SET [0x0F+X], 0x00	;MMU (disabled)
	SET [0x12+X], 0x00	;write back pointer

	SET X, 0x3080
	SET [0x00+X], 0x00	;A
	SET [0x01+X], 0x00	;B
	SET [0x02+X], 0x00	;C
	SET [0x03+X], 0x00	;X
	SET [0x04+X], 0x00	;Y
	SET [0x05+X], 0x00	;Z
	SET [0x06+X], 0x00	;I
	SET [0x07+X], 0x00	;J
	SET [0x08+X], 0x00	;OVERFLOW
	SET [0x09+X], bar	;PC
	SET [0x0A+X], 0x9FFF	;SP
	SET [0x0B+X], 0x00	;TICK
	SET [0x0C+X], 0x00	;TIMER
	SET [0x0F+X], 0x09	;MMU (write enable range 0x8000-0x9FFF)
	SET [0x12+X], 0x00	;write back pointer	




	SET X, 0x3000		;point to the first VRA



;
; initialize the point look up tables for read/execute/write cpu operations
;
	SET PC, gen_lookup_tables

;
; Start the emulation
;
;	emulation is broken down into four steps:
;		1) get/decode instruction
;		2) read values 
;		3) execute instruction
;		4) write value a

:begin
:load_inst
	;simple task switching 
	;toggle between the two programs every virtual instruction cycle
	ADD X, 0x0020	;increment to the next virtual register array
	IFE X, 0x30A0
	SET X, 0x3000

	;load PC into I
	SET I, [0x09+X] 
	
	;load the raw opcode into the registers
	SET A, [I] ;a
	SET B, [I] ;b
	SET C, [I] ;instruction

	SET Y, C	;check for extended instruction (Y used as temp register)
	AND Y, 0x0F	;if lower 4 bits are 0, then is extended instruction 
	IFE Y, 0  
	SET PC, load_extended 
	SET PC, load_basic

:load_extended
	;decompose (shift/mask) the instruction into opcode, b
	;(b is the 6 bit value type, a is not used for extended opcodes)
	SHR A, 0x0A	
	AND A, 0x003F	;a
	SET B, 0	;b
	SHR C, 0x04	;lower 4 bits not used
	AND C, 0x3F	;mask the 6 bit instruction
	BOR C, 0x100	;set a temporary bit flag to indicate an extended instruction
	SET PC, decode_val

:load_basic
	;decompose (shift/mask) the instruction into opcode, a, b
	;(a and b are 6 bit value types)
	SHR A, 0x04	;a
	AND A, 0x3F
	SHR B, 0x0A	
	AND B, 0x3F	;b
	AND C, 0x0F	;4 bit instruction
	;SET PC, decode_val

:decode_val
	SET Z, 0x5000 ; decode look up table (a values)
	ADD Z, A      ; add the value type offset
	SET PC, [Z]

:decode_val_cont
	SET Z, 0x5500 ; decode look up table (b values)
	ADD Z, B      ; add the value type offset
	SET PC, [Z]   ; goto the handler
	
:decode_val_done
	;SET PC, exe_instruction

:exe_instruction
	; at this point the values a & b have been loaded
	; into registers Y and J. Next step is to execute
	; the opcode.
	IFG C, 0xFF	     ; check to see if the temp bit flag 
			     ; was set indicating extended instruction
	SET PC, exe_extended ; extended instruction
	;SET PC,	exe_basic    ; basic instruction

:exe_basic	      ; execute a basic instruction
	SET Z, 0x6000 ; basic instruction look up table
	ADD Z, C      ; add the instruction offset (op code value)
	SET PC, [Z]   ; goto the handler

:exe_extended		; execute an extended instruction
	AND C, 0x3F	; clear the extended instruction bit flag
	SET Z, 0x6200	; extended instruction look up table
	ADD Z, C	; add the instruction offset (op code value)
	SET PC, [Z]	; goto the handler


:write_back
	;check to see if MMU is used
	IFN [0x0F+X], 0x00
	SET PC, mmu		;MMU is enabled, jump to the MMU handler

:write_back_cont
	; goto the write back handler to store the result
	SET Z, 0x5100 ; write back look up table
	ADD Z, A      ; add offset (write back type)
	SET PC, [Z]

:post_exe_skip_next
	ADD I, 0x01		; increment the PC to
	SET Z, [I]		; get the next instruction
	AND Z, 0x0F 		; test for extended instruction
	IFE Z, 0x00		; extended instructions are one word
	SET PC, post_exe	; jump to the normal handler and continue  
				; else, get the value types
	SET A, [I]	 	; a
	SET B, [I] 		; b	
	SHR A, 0x04		; decompose (shift/mask) the instruction into a, b
	AND A, 0x3F		; (a and b are 6 bit value types)
	SHR B, 0x0A	
	AND B, 0x3F	
				; next byte value types increment the PC (from DCPU spec):
				; 0x10-0x17: [next word + register]
				; 0x1e: [next word]
				; 0x1f: next word (literal)
				; if in this range increment the PC
	IFG 0x10, A				; test len of values	;A < 0x10 (16)
	SET PC, post_exe_skip_next_testb	; a is embedded
	IFG A, 0x1F							;A > 0x1F (31)
	SET PC, post_exe_skip_next_testb	; a is embedded
	IFG 0x18, A							;A < 18
	ADD I, 0x01				; a is in next word
	IFG A, 0x1D
	ADD I, 0x01				; a is in next word
:post_exe_skip_next_testb
	IFG 0x10, B
	SET PC, post_exe			; b is embedded
	IFG B, 0x1F
	SET PC, post_exe			; b is embedded
	IFG 0x18, B
	ADD I, 0x01				; b is in next word
	IFG B, 0x1D
	ADD I, 0x01				; b is in next word
	;continue into post_exe
:post_exe			; called post execution
	ADD I, 0x01		; increment the PC
	SET [0x09+X], I		; store the updated PC
:post_exe_dont_update_pc	; called post execution when the PC
				; was modifed by the opcode (JSR or SET PC)
	ADD [0x0B+X], 1		; increment the TICK counter

				;finally process any service calls
	SET A, [0x0F+X]		;get the mmu register 
	SHL A, 0x0C		;shift left three places (12 bits)
	BOR A, 0x0FFF		;complete the high address
	IFE A, 0x0FFF		;mmu is disabled, check 0xFFFF for service call request
	SET A, 0xFFFF
	SET B, [A]		;get the data
	IFE B, 0xBEEF		;service call was requested, call the handler
	SET PC, sc
:post_sc
	SET PC, load_inst	; continue with the next instruction


:sc
	SET [A], 0x0000		; clear the service call byte
	; handle the service call
	SET C, [X]		; get service call index from the VRA (reg A)
	AND C, 0x0F		; mask out the upper bytes

	SET Z, 0x6300		; service call look up table
	ADD Z, C		; add offset (service call index)
	SET PC, [Z]


:mmu
;	memory management unit
;	 	0xXXaa = MMU access, 7 pages of 8k words (+4k block of shared memory):
;		0xXX01 - r/w access from 0x0000 to 0x1FFF (video buffer: 0xE000 to 0xE1FF )
;		0xXX03 - r/w access from 0x2000 to 0x3FFF (video buffer: 0xE200 to 0xE3FF )
;		0xXX05 - r/w access from 0x4000 to 0x5FFF (video buffer: 0xE400 to 0xE5FF )
;		0xXX07 - r/w access from 0x6000 to 0x7FFF (video buffer: 0xE600 to 0xE7FF )
;		0xXX09 - r/w access from 0x8000 to 0x9FFF (video buffer: 0xE800 to 0xE8FF )
;		0xXX0B - r/w access from 0xA000 to 0xBFFF (video buffer: 0xEA00 to 0xE9FF )
;		0xXX0D - r/w access from 0xC000 to 0xDFFF (video buffer: 0xEC00 to 0xEAFF )
;		0xXXXX - global r/w access from 0xF000 to 0xFFFF

	;evaluate value a, if destination is an address check write permisions
	;	0x08-0x0f: [register]
    	;	0x10-0x17: [next word + register]
	;	0x1e: [next word]
	IFE 0x1E, A
	SET PC, mmu_in		;is [next word]

	IFG A, 0x07
	SET PC, mmu_r		;might be a pointer
	SET PC, mmu_exit	;not a pointer	
:mmu_r  IFG A, 0x0F
	SET PC, mmu_o		;not a [register]
	SET PC, mmu_ir		;is [register]

:mmu_o	IFG A, 0x17
	SET PC,mmu_n		;not [next word + register]
	SET PC, mmu_io		;is [next word + register]	
:mmu_n
	IFG A, 0x17
	SET PC, mmu_exit	;A>0x17, not a pointer

:mmu_in ;is next word
:mmu_io ;is offset + reg
	SET J, [0x12+X]		;get the address
	SET PC, mmu_cont

:mmu_ir	;is register
	SET J, A		;copy value a
	SUB J, 0x08		;map value type to register offset
	ADD J, X		;add to the the virtual register location
	SET J, [J]		;get the address

:mmu_cont
	;check write permissions for destination address 
	SET Z, [0x0F+X]		;get the mmu register 
	SHL Z, 0x0C		;shift left three places (12 bits)
	SET B, J		;copy the dest address into temp reg B
	AND B, 0xF000		;mask the lower 12 bits
	IFE B, Z		;check the second 4K
	SET PC, mmu_exit	;write enabled
	SUB Z, 0x1000		
	IFE B, Z		;check the first 4K
	SET PC, mmu_exit	;write enabled
	SET B, 0xF000		;check shared memory
	IFE B, Z		;
	SET PC, mmu_exit	;write enabled


	;out of bounds write attempt, jump to post_exe without 
	;writing value to destination
	SET PC, post_exe

:mmu_exit
	;write enabled continue with the write back handler
	SET PC, write_back_cont



;
;instruction implementation
;	at this point the values a & b have been loaded
;	into Y & J.

:_set
	SET Y, J
	SET PC, write_back
:_add
	ADD Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_sub
	SUB Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_mul
	MUL Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_div
	DIV Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_mod
	MOD Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_shl
	SHL Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_shr
	SHR Y, J
	SET [0x08+X],O	;capture overflow register
	SET PC, write_back

:_and
	AND Y, J
	SET PC, write_back

:_bor
	BOR Y, J
	SET PC, write_back

:_xor
	XOR Y, J
	SET PC, write_back

					; branching instructions dont write back, jump to post exe.
					; instructions may be more than 1 word in length, skip
					; next instruction for false compares.
:_ife
	IFE Y, J
	SET PC, post_exe			
	SET PC, post_exe_skip_next
:_ifn
	IFN Y, J
	SET PC, post_exe
	SET PC, post_exe_skip_next
:_ifg
	IFG Y, J
	SET PC, post_exe
	SET PC, post_exe_skip_next
:_ifb
	IFB Y, J
	SET PC, post_exe
	SET PC, post_exe_skip_next
:_jsr
	SET B, [0x0A+X]	;load the SP address
	SUB B, 1	;decrement the pointer
	ADD I, 0x01	;increment the PC (point to the next instruction)
	SET [B], I	;write the PC to the stack
	SET [0x0A+X],B	;store the SP
	SET [0x09+X], Y	;load a into the PC
	SET PC, post_exe_dont_update_pc

;
;
;value loader
;
; - the following routines load the value types.
;   value a is stored in Y and value b is stored in J
;   the same routines are called for both a and b
;   high bit of C is used to flag the load destination
;
;   the pointer for an indirect load of value a is stored 
;   for post-execution write back. 
;   the exception is [register] loads, in this case the virtual
;   registers already contain the address.

;
; REG _A
;

:_ld_a_a
	SET Y, [X]
	SET PC, decode_val_cont
:_ld_a_b
	SET J, [X]
	SET PC, decode_val_done
:_lid_a_a		;indirect load register into value a or b
	SET Z, [X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_a_b
	SET Z, [X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_a_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_a_b
	ADD I, 0x01	;inc the PC
	SET Z, [X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done

;
; REG B
;

:_ld_b_a
	SET Y, [0x01+X]
	SET PC, decode_val_cont
:_ld_b_b
	SET J, [0x01+X]
	SET PC, decode_val_done
:_lid_b_a		;indirect load register into value a or b
	SET Z, [0x01+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_b_b
	SET Z, [0x01+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_b_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x01+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_b_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x01+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done

;
; REG C
;

:_ld_c_a
	SET Y, [0x02+X]
	SET PC, decode_val_cont
:_ld_c_b
	SET J, [0x02+X]
	SET PC, decode_val_done
:_lid_c_a		;indirect load register into value a or b
	SET Z, [0x02+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_c_b
	SET Z, [0x02+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_c_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x02+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_c_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x02+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done


;
; REG X
;

:_ld_x_a
	SET Y, [0x03+X]
	SET PC, decode_val_cont
:_ld_x_b
	SET J, [0x03+X]
	SET PC, decode_val_done
:_lid_x_a		;indirect load register into value a or b
	SET Z, [0x03+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_x_b
	SET Z, [0x03+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_x_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x03+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_x_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x03+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done

;
; REG Y
;

:_ld_y_a
	SET Y, [0x04+X]
	SET PC, decode_val_cont
:_ld_y_b
	SET J, [0x04+X]
	SET PC, decode_val_done
:_lid_y_a		;indirect load register into value a or b
	SET Z, [0x04+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_y_b
	SET Z, [0x04+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_y_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x04+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_y_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x04+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done

;
; REG Z
;

:_ld_z_a
	SET Y, [0x05+X]
	SET PC, decode_val_cont
:_ld_z_b
	SET J, [0x05+X]
	SET PC, decode_val_done
:_lid_z_a		;indirect load register into value a or b
	SET Z, [0x05+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_z_b
	SET Z, [0x05+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_z_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x05+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_z_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x05+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done
;
; REG I
;

:_ld_i_a
	SET Y, [0x06+X]
	SET PC, decode_val_cont
:_ld_i_b
	SET J, [0x06+X]
	SET PC, decode_val_done
:_lid_i_a
	SET Z, [0x06+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_i_b
	SET Z, [0x06+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_i_a
	ADD I, 0x01	;inc the PC
	SET Z, [0x06+X]	;load from register 
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_i_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x06+X]	;load from register 
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done
;
; REG J
;

:_ld_j_a
	SET Y, [0x07+X]
	SET PC, decode_val_cont
:_ld_j_b
	SET J, [0x07+X]
	SET PC, decode_val_done
:_lid_j_a		;indirect load register into value a or b
	SET Z, [0x07+X]	;dereference the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lid_j_b
	SET Z, [0x07+X]	;dereference the pointer
	SET J, [Z]
	SET PC, decode_val_done
:_lido_j_a		;indirect load (with offset) register into value a or b
	ADD I, 0x01	;inc the PC
	SET Z, [0x07+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET [0x12+X], Z ;save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lido_j_b
	ADD I, 0x01	;inc the PC
	SET Z, [0x07+X]	;load from register a
	ADD Z, [I]	;add the next word
	SET J, [Z]
	SET PC, decode_val_done

;
;stack/memory/literal loads
;

:_lpop_a
	SET Z, [0x0A+X]		; read
	ADD [0x0A+X], 0x01	; pop (post increment the SP)
	SET [0x12+X], Z 	; save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lpop_b
	SET Z, [0x0A+X]		; read
	ADD [0x0A+X], 0x01	; pop (post increment the SP)
	SET J, [Z]
	SET PC, decode_val_done
:_lpeek_a
	SET Z, [0x0A+X]		;read stack value
	SET [0x12+X], Z 	; save the pointer
	SET Y, [Z]
	SET PC, decode_val_cont
:_lpeek_b
	SET Z, [0x0A+X]		;read stack value
	SET J, [Z]
	SET PC, decode_val_done
:_lpush_a
	SUB [0x0A+X], 0x01	;push (pre decrement the SP)
	SET Z, [0x0A+X]		;get the SP
	SET [0x12+X], Z 	;save the pointer for write back (address)
	SET Y, [Z]		;dereference the pointer and get the value
	SET PC, decode_val_cont
:_lpush_b
	SUB [0x0A+X], 0x01	;push (pre decrement the SP)
	SET Z, [0x0A+X]		;get the SP
	SET J, [Z]
	SET PC, decode_val_done
:_lsp_a
	SET Y, [0x0A+X]
	SET PC, decode_val_cont
:_lsp_b
	SET J, [0x0A+X]
	SET PC, decode_val_done
:_lpc_a
	SET Y, [0x09+X]
	SET PC, decode_val_cont
:_lpc_b
	SET J, [0x09+X]
	SET PC, decode_val_done
:_lo_a
	SET Y, [0x08+X]
	SET PC, decode_val_cont
:_lo_b
	SET J, [0x08+X]
	SET PC, decode_val_done		
:_lidw_a			;load indirect next word
	ADD I, 0x01		;inc the PC
	SET Z, [I]		;load the next word
	SET [0x12+X], Z 	;save the pointer for write back (address)
	SET Y, [Z]		;dereference the pointer and get the value
	SET PC, decode_val_cont
:_lidw_b
	ADD I, 0x01		;inc the PC
	SET Z, [I]		;load the next word
	SET J, [Z]
	SET PC, decode_val_done				
:_ldw_a				;load literal next word
	ADD I, 0x01		;inc the PC
	SET Y, [I]
	SET PC, decode_val_cont
:_ldw_b
	ADD I, 0x01		;inc the PC
	SET J, [I]
	SET PC, decode_val_done
:_llv_a				;load literal value
	SET Y, A
	SUB Y, 0x20		;subtract 0x20 to get the actual literal value
	SET PC, decode_val_cont
:_llv_b
	SET J, B
	SUB J, 0x20		;subtract 0x20 to get the actual literal value
	SET PC, decode_val_done

;
; value writer
;
; - post execute write back operation (store the result)
;

:_wd_a
	SET [0x00+X], Y
	SET PC, post_exe
:_wid_a
	SET Z, [0x00+X] 
	SET [Z], Y
	SET PC, post_exe

:_wido_a
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_b
	SET [0x01+X], Y
	SET PC, post_exe

:_wid_b
	SET Z, [0x01+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_b
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_c
	SET [0x02+X], Y
	SET PC, post_exe

:_wid_c
	SET Z, [0x02+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_c
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_x
	SET [0x03+X], Y
	SET PC, post_exe

:_wid_x
	SET Z, [0x03+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_x
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_y
	SET [0x04+X], Y
	SET PC, post_exe

:_wid_y
	SET Z, [0x04+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_y
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_z
	SET [0x05+X], Y
	SET PC, post_exe

:_wid_z
	SET Z, [0x05+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_z
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_i
	SET [0x06+X], Y
	SET PC, post_exe

:_wid_i
	SET Z, [0x06+X] 
	SET [Z], Y
	SET PC, post_exe

:_wido_i
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wd_j
	SET [0x07+X], Y
	SET PC, post_exe

:_wid_j
	SET Z, [0x07+X] 
	SET [Z], Y
	SET PC, post_exe
:_wido_j
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wpop
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y		;write 'a' to the stack
	SET PC, post_exe
:_wpeek
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y		;write 'a' to the stack
	SET PC, post_exe

:_wpush
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y		;write 'a' to the stack
	SET PC, post_exe
:_wsp				; write SP
	SET [0x0A+X], Y
	SET PC, post_exe

:_wpc				; write PC
	SET [0x09+X], Y
	SET PC, post_exe_dont_update_pc

:_wo				; write overflow
	SET [0x08+X], Y
	SET PC, post_exe

:_widw
	SET Z, [0x12+X] 	;load the stored destination pointer
	SET [Z], Y
	SET PC, post_exe
:_wdw				;write literal word (illegal op)
:_wlv				;write literal value (illegal op)
	;NOP
	SET PC, post_exe



;
; OS service functions
;
;

:_ossf1			;OS service function one: clear the screen, 
			;VRA reg B is screen color
			;verify write access to screen:
	IFE A, 0xFFFF	;	no mmu
	SET PC, _sf1c
	IFE A, 0x9FFF	;	8000-9FFF access
	SET PC, _sf1c	
	IFE A, 0x8FFF	;	7000-8FFF access
	SET PC, _sf1c
			;all other values: write access failed
	SET [X], 0	;clear VRA A
	SET [0x01+X], 0	;set VRA B (fail)		
	SET PC, post_sc


:_sf1c
	SET A, 0x8000	;set a to the start of the screen buffer	
	SET B, [0x01+X]	;get the color from VRA B 
:_sf1l	ADD A, 0x01
	SET [A], B
	IFG 0x8200, A
	SET PC, _sf1l	;loop until clear
	SET [X], 0	;clear VRA A
	SET [0x01+X], 1	;set VRA B (pass)
	SET PC, post_sc


:_ossf2			; not implemented
:_ossf3
:_ossf4
:_ossf5
:_ossf6
:_ossf7
:_ossf8
:_ossf9
:_ossfA
:_ossfB
:_ossfC
:_ossfD
:_ossfE
:_ossfF
	SET PC, post_sc



;
; look up table generation
;
;	- pointer tables for read / execute / write handlers 
;
;

:gen_lookup_tables
				;basic instructions
	SET J, 0x6000
	ADD J, 0x01
	SET [J], _set
	ADD J, 0x01
	SET [J], _add
	ADD J, 0x01
 	SET [J], _sub
	ADD J, 0x01
 	SET [J], _mul
	ADD J, 0x01
 	SET [J], _div
	ADD J, 0x01
 	SET [J], _mod
	ADD J, 0x01
 	SET [J], _shl
	ADD J, 0x01
 	SET [J], _shr
	ADD J, 0x01
 	SET [J], _and
	ADD J, 0x01
 	SET [J], _bor
	ADD J, 0x01
 	SET [J], _xor
	ADD J, 0x01
 	SET [J], _ife
	ADD J, 0x01
 	SET [J], _ifn
	ADD J, 0x01
 	SET [J], _ifg
	ADD J, 0x01
 	SET [J], _ifb
				;extended instructions
	SET J, 0x6200
	ADD J, 0x01
	SET [J], _jsr

				;value type loaders (A)
	SET J, 0x5000
	;direct load
	SET [J], _ld_a_a
	ADD J, 0x01
	SET [J], _ld_b_a
	ADD J, 0x01
	SET [J], _ld_c_a
	ADD J, 0x01
	SET [J], _ld_x_a
	ADD J, 0x01
	SET [J], _ld_y_a
	ADD J, 0x01
	SET [J], _ld_z_a
	ADD J, 0x01
	SET [J], _ld_i_a
	ADD J, 0x01
	SET [J], _ld_j_a
	
				;indirect load
	ADD J, 0x01
	SET [J], _lid_a_a
	ADD J, 0x01
	SET [J], _lid_b_a
	ADD J, 0x01
	SET [J], _lid_c_a
	ADD J, 0x01
	SET [J], _lid_x_a
	ADD J, 0x01
	SET [J], _lid_y_a
	ADD J, 0x01
	SET [J], _lid_z_a
	ADD J, 0x01
	SET [J], _lid_i_a
	ADD J, 0x01
	SET [J], _lid_j_a

				;indirect load /w word offset
	ADD J, 0x01
	SET [J], _lido_a_a
	ADD J, 0x01
	SET [J], _lido_b_a
	ADD J, 0x01
	SET [J], _lido_c_a
	ADD J, 0x01
	SET [J], _lido_x_a
	ADD J, 0x01
	SET [J], _lido_y_a
	ADD J, 0x01
	SET [J], _lido_z_a
	ADD J, 0x01
	SET [J], _lido_i_a
	ADD J, 0x01
	SET [J], _lido_j_a

				;stack/memory loads
	ADD J, 0x01
	SET [J], _lpop_a
	ADD J, 0x01
	SET [J], _lpeek_a
	ADD J, 0x01
	SET [J], _lpush_a
	ADD J, 0x01
	SET [J], _lsp_a
	ADD J, 0x01
	SET [J], _lpc_a
	ADD J, 0x01
	SET [J], _lo_a
	ADD J, 0x01
	SET [J], _lidw_a
	ADD J, 0x01
	SET [J], _ldw_a

				;5 bit literal loads 
				;(all point to the same function)
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a
	ADD J, 0x01
	SET [J], _llv_a



				;value type loaders (B)
	SET J, 0x5500
	;direct load
	SET [J], _ld_a_b
	ADD J, 0x01
	SET [J], _ld_b_b
	ADD J, 0x01
	SET [J], _ld_c_b
	ADD J, 0x01
	SET [J], _ld_x_b
	ADD J, 0x01
	SET [J], _ld_y_b
	ADD J, 0x01
	SET [J], _ld_z_b
	ADD J, 0x01
	SET [J], _ld_i_b
	ADD J, 0x01
	SET [J], _ld_j_b
	
				;indirect load
	ADD J, 0x01
	SET [J], _lid_a_b
	ADD J, 0x01
	SET [J], _lid_b_b
	ADD J, 0x01
	SET [J], _lid_c_b
	ADD J, 0x01
	SET [J], _lid_x_b
	ADD J, 0x01
	SET [J], _lid_y_b
	ADD J, 0x01
	SET [J], _lid_z_b
	ADD J, 0x01
	SET [J], _lid_i_b
	ADD J, 0x01
	SET [J], _lid_j_b

				;indirect load /w word offset
	ADD J, 0x01
	SET [J], _lido_a_b
	ADD J, 0x01
	SET [J], _lido_b_b
	ADD J, 0x01
	SET [J], _lido_c_b
	ADD J, 0x01
	SET [J], _lido_x_b
	ADD J, 0x01
	SET [J], _lido_y_b
	ADD J, 0x01
	SET [J], _lido_z_b
	ADD J, 0x01
	SET [J], _lido_i_b
	ADD J, 0x01
	SET [J], _lido_j_b

				;stack/memory loads
	ADD J, 0x01
	SET [J], _lpop_b
	ADD J, 0x01
	SET [J], _lpeek_b
	ADD J, 0x01
	SET [J], _lpush_b
	ADD J, 0x01
	SET [J], _lsp_b
	ADD J, 0x01
	SET [J], _lpc_b
	ADD J, 0x01
	SET [J], _lo_b
	ADD J, 0x01
	SET [J], _lidw_b
	ADD J, 0x01
	SET [J], _ldw_b

				;5 bit literal loads 
				;(all point to the same function)
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b
	ADD J, 0x01
	SET [J], _llv_b


				;value type write-back
	SET J, 0x5100
	;direct write
	SET [J], _wd_a
	ADD J, 0x01
	SET [J], _wd_b
	ADD J, 0x01
	SET [J], _wd_c
	ADD J, 0x01
	SET [J], _wd_x
	ADD J, 0x01
	SET [J], _wd_y
	ADD J, 0x01
	SET [J], _wd_z
	ADD J, 0x01
	SET [J], _wd_i
	ADD J, 0x01
	SET [J], _wd_j
	
				;indirect write
	ADD J, 0x01
	SET [J], _wid_a
	ADD J, 0x01
	SET [J], _wid_b
	ADD J, 0x01
	SET [J], _wid_c
	ADD J, 0x01
	SET [J], _wid_x
	ADD J, 0x01
	SET [J], _wid_y
	ADD J, 0x01
	SET [J], _wid_z
	ADD J, 0x01
	SET [J], _wid_i
	ADD J, 0x01
	SET [J], _wid_j

				;indirect write /w word offset
	ADD J, 0x01
	SET [J], _wido_a
	ADD J, 0x01
	SET [J], _wido_b
	ADD J, 0x01
	SET [J], _wido_c
	ADD J, 0x01
	SET [J], _wido_x
	ADD J, 0x01
	SET [J], _wido_y
	ADD J, 0x01
	SET [J], _wido_z
	ADD J, 0x01
	SET [J], _wido_i
	ADD J, 0x01
	SET [J], _wido_j

				;stack/memory write
	ADD J, 0x01
	SET [J], _wpop
	ADD J, 0x01
	SET [J], _wpeek
	ADD J, 0x01
	SET [J], _wpush
	ADD J, 0x01
	SET [J], _wsp
	ADD J, 0x01
	SET [J], _wpc
	ADD J, 0x01
	SET [J], _wo
	ADD J, 0x01
	SET [J], _widw
	ADD J, 0x01
	SET [J], _wdw

				;5 bit literal writes 
				; invalid operation?? 
				; (all point to the same NOP handler)
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
	ADD J, 0x01
	SET [J], _wlv
 
				; OS service functions
	SET J, 0x6300
	ADD J, 0x01
	SET [J], _ossf1
	ADD J, 0x01
	SET [J], _ossf2
	ADD J, 0x01
	SET [J], _ossf3
	ADD J, 0x01
	SET [J], _ossf4
	ADD J, 0x01
	SET [J], _ossf5
	ADD J, 0x01
	SET [J], _ossf6
	ADD J, 0x01
	SET [J], _ossf7
	ADD J, 0x01
	SET [J], _ossf8
	ADD J, 0x01
	SET [J], _ossf9
	ADD J, 0x01
	SET [J], _ossfA
	ADD J, 0x01
	SET [J], _ossfB
	ADD J, 0x01
	SET [J], _ossfC
	ADD J, 0x01
	SET [J], _ossfD
	ADD J, 0x01
	SET [J], _ossfE
	ADD J, 0x01
	SET [J], _ossfF
				; after generating the look up tables
				; goto 'begin' to start the emulation
	SET PC, begin
	

:end
